#### 为什么拆分单体应用

##### 单体应用优势

- 开发简单直接, 代码和项目集中管理

- 只需要维护一个工程, 节省维护系统运行的人力成本

- 排查问题简单, 只需要关注一个进程, 目标性强

  > 只适合系统初期开发, 快速投放市场, 完成验证

##### 单体应用痛点

- 技术层面上, 数据库可能会成为系统瓶颈

  > 随着业务的拓展, DAU的增加, 扩容服务器势必会导致数据库连接的增加, 进而导致服务稳定性受到影响

- 随着业务的拓展, 单体应用会增加研发成本, 抑制研发效率

  > 一套代码库会导致代码冲突概率极大增加, 功能间严重耦合, 很小的修改都可能会导致其他功能的不可用, 测试时需要整体回归, 延长了交付时间

- 单体应用后期对系统运维也有很大影响

  > 代码行数由刚开始几千行增加到几万行, 几十万行, 一次构建从编译, 到单元测试, 打包, 上传正式环境, 花费的时间大大增加, 任何小的改动都需要构建整个项目, 上线过程变的非常不灵活

#### 微服务拆分原则

- 单一服务高内聚, 低耦合

  > 每个服务只完成自己职责之内的任务, 对于不属于自己职责的功能, 交由其他服务来完成

- 服务拆分粒度, 很多事情不是一蹴而就的事, 先粗略拆分, 再逐渐细化

  > 服务的太细性能会下降, 运维成本会增加

- 服务的拆分需要尽量避免影响产品日常迭代

  > 优先剥离比较独立的边界服务(如短信服务, 邮件服务等), 从非核心服务开始, 降低拆分服务对现有业务的影响;
  >
  > 当两个服务存在依赖关系时, 优先拆分被依赖的服务, 否则依赖方会依赖一体化应用中的模块, 还是会影响快速部署能力;

- 服务接口的定义要具备可扩展性

  > 服务拆分之后, 是一个独立进程, 所以服务之间的通信是跨进程的网络通信, 这种通信模型下需要注意, 服务接口的定义需要可扩展;

#### 微服务化带来的问题和解决思路

- 服务接口的调用, 不再是同一进程内的方法调用, 而是跨进程的网络调用, 这回增加接口的响应时间

  > 服务注册中心, 存储服务的IP, port, 进行内网RPC调用;

- 多服务间复杂的依赖管理, 可能会导致服务的雪崩

  > 引入服务治理体系, 采用熔断, 降级, 限流, 超时控制等方法, 将问题限制在单一服务之中, 保护服务网络中其他服务不受影响;

- 服务拆分多进程之后, 一个请求的调用链路, 设计多个服务, 问题定位成本急剧增加

  > 引入分布式追踪工具, 以及更细致的服务端监控报表

